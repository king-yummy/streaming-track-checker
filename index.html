<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PLLI 스밍체크</title>
    <link rel="manifest" href="manifest.json" />
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
    <link rel="apple-touch-icon" href="icon-512.png" />
    <link
      href="https://fonts.googleapis.com/css2?family=Jua&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#dbeafe" />
    <meta name="google-adsense-account" content="ca-pub-9063401338616510" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css"
    />
    <script>
      window.tailwindConfig = {
        theme: {
          fontFamily: {
            sans: ["Pretendard", "ui-sans-serif", "system-ui"],
          },
        },
      };
    </script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
      @keyframes bgShift {
        0%,
        100% {
          background-color: #dbeafe;
        }
        50% {
          background-color: #bfdbfe;
        }
      }
      .playing {
        animation: bgShift 2.5s ease-in-out infinite;
      }
      html,
      body {
        background-color: white;
      }
    </style>
  </head>
  <body
    class="font-sans bg-gray-100 min-h-screen flex flex-col items-center p-4"
  >
    <div
      id="loading-screen"
      class="fixed inset-0 z-50 bg-white flex flex-col justify-center items-center"
    >
      <img
        src="icon-192.png"
        alt="스밍체크 로고"
        class="w-16 h-16 mb-4 animate-bounce"
      />
      <p class="text-gray-700 font-medium text-lg">잠깐 기다리면 보여주겠지~</p>
    </div>

    <!-- 헤더 -->
    <header class="w-full max-w-md mt-2 mb-2 text-center">
      <h1
        class="text-3xl tracking-wide"
        style="font-family: 'Jua', sans-serif; font-weight: 400"
      >
        <span class="font-bold">「かくれんぼ」</span> 스트리밍 리스트
      </h1>
      <div
        class="flex justify-between items-center mt-2 text-sm text-gray-700 px-1"
      >
        <div class="flex items-center gap-2">
          <span>정각 알림</span>
          <label class="relative inline-flex items-center cursor-pointer">
            <input type="checkbox" id="alarm-toggle" class="sr-only peer" />
            <div
              class="w-11 h-6 bg-gray-300 rounded-full peer peer-checked:bg-blue-500 transition-all"
            ></div>
            <div
              class="absolute left-0.5 top-0.5 w-5 h-5 bg-white rounded-full shadow peer-checked:translate-x-full transition-all"
            ></div>
          </label>
        </div>
        <span class="text-xs text-gray-500">25.06.16 ver.</span>
      </div>
    </header>

    <main class="w-full max-w-md space-y-2 overflow-auto">
      <ul id="playlist" class="space-y-2"></ul>
    </main>

    <section
      id="dashboard"
      class="w-full max-w-md mt-4 mb-2 p-4 bg-white rounded-2xl shadow flex flex-col items-center space-y-3"
    >
      <h2 class="text-sm text-gray-600 font-semibold">
        16일 자정부터 스밍이 끊기지 않았다면!
      </h2>
      <div class="grid grid-cols-3 gap-4 w-full text-center">
        <div>
          <p class="text-[11px] text-gray-500 mb-1">かくれんぼ</p>
          <p class="text-2xl font-bold">
            <span id="count-kakurenbo">0</span>회
          </p>
        </div>
        <div>
          <p class="text-[11px] text-gray-500 mb-1">Rizz - JP</p>
          <p class="text-2xl font-bold"><span id="count-rizz">0</span>회</p>
        </div>
        <div>
          <p class="text-[11px] text-gray-500 mb-1">Chroma Drift - JP</p>
          <p class="text-2xl font-bold"><span id="count-chroma">0</span>회</p>
        </div>
      </div>
    </section>

    <footer
      class="w-full max-w-md text-center text-xs text-gray-500 mt-2 mb-4 space-y-2"
    >
      <p>플레이브 음원총공팀의 스트리밍 리스트에 따라 운영되는 페이지입니다.</p>
      <p>
        문의 및 건의사항은 X(트위터)
        <strong
          ><a
            href="https://x.com/plave_pretty?s=21&t=KweQO4B2QEKZ954vZ1zJ5"
            target="_blank"
            rel="noopener"
            class="text-blue-600 hover:underline"
            >@plave_pretty</a
          ></strong
        >
        로 보내주세요.
      </p>
      <p class="text-[10px] text-gray-400 mt-2">
        이 페이지는 플레이브 팬덤 <strong>PLLI</strong>만을 위해
        제작하였습니다.<br />
        타 팬덤에서의 무단 복제·재가공·사용 발견 시 빠르게 대응합니다. 🕵️‍♀️
      </p>
    </footer>

    <!-- 스크립트 -->
    <script>
      const SHEET_URL =
        "https://docs.google.com/spreadsheets/d/e/2PACX-1vR7sUDMYoUsBpvEC9LjO25CnstexV74iKXfwRWVdqpQCOm65rzvJ6RrnedOv6JSqEYJNqyr2cje75CJ/pub?gid=0&single=true&output=csv";

      const START_AT_MS = new Date("2025-06-16T00:00:00+09:00").getTime();

      const TARGETS = {
        kakurenbo: "かくれんぼ",
        rizz: "Rizz - japanese Ver.",
        chroma: "Chroma Drift - japanese Ver.",
      };

      const PER_CYCLE = {
        kakurenbo: 4,
        rizz: 3,
        chroma: 1,
      };

      let schedule = [];

      const toSec = (mmss) => {
        const [m, s] = mmss.split(":").map(Number);
        return m * 60 + s;
      };

      const formatKoreanTime = (str) => {
        const [m, s] = str.split(":").map(Number);
        return `${m}분 ${s.toString().padStart(2, "0")}초`;
      };

      const formatTimeMMSS = (sec) => {
        const m = Math.floor(sec / 60);
        const s = sec % 60;
        return `${m}:${s.toString().padStart(2, "0")}`;
      };

      async function loadSchedule() {
        const res = await fetch(SHEET_URL);
        const text = await res.text();
        const rows = text.trim().split("\n").slice(1);

        schedule = rows.map((line) => {
          const [title, start, end, cover] = line
            .split(",")
            .map((s) => s.trim());
          return {
            title,
            start,
            end,
            cover,
            startSec: toSec(start),
            endSec: toSec(end),
          };
        });

        renderPlaylist();
        tick();
        setInterval(tick, 1000);

        document.getElementById("loading-screen").style.display = "none";
      }

      function renderPlaylist() {
        const ul = document.getElementById("playlist");
        ul.innerHTML = schedule
          .map(
            (item, i) => `
      <li data-index="${i}" class="flex flex-col p-2 rounded-lg shadow w-full opacity-50 transition-all bg-white text-[13px]">
        <div class="flex items-center gap-2">
          <div class="w-10 h-10 flex-shrink-0 bg-gray-200 rounded overflow-hidden">
            <img src="${item.cover}" alt="${
              item.title
            }" class="w-full h-full object-cover" />
          </div>
          <div class="flex-1">
            <p class="font-medium truncate">${i + 1}. ${item.title}</p>
            <p class="text-xs text-gray-500">${formatKoreanTime(
              item.start
            )} ~ ${formatKoreanTime(item.end)}</p>
          </div>
        </div>
        <div class="flex items-center gap-1 text-[11px] px-1 mt-1">
          <span id="start-${i}" class="w-[40px] text-left text-gray-400">+0:00</span>
          <div class="flex-1 h-1 bg-gray-200 rounded overflow-hidden">
            <div id="p-${i}" class="h-full bg-blue-400 transition-all" style="width:0%"></div>
          </div>
          <span id="end-${i}" class="w-[40px] text-right text-gray-400">-0:00</span>
        </div>
      </li>`
          )
          .join("");
      }

      function tick() {
        const now = new Date();
        const diffSec = Math.max(
          0,
          Math.floor((Date.now() - START_AT_MS) / 1000)
        );
        const cycles = Math.floor(diffSec / 3600);
        const secInLoop = diffSec % 3600;

        updateHighlight(secInLoop);
        updateCounts(cycles, secInLoop);
        updateProgress(secInLoop);
      }

      function updateHighlight(secInLoop) {
        const idx = schedule.findIndex(
          (item) => secInLoop >= item.startSec && secInLoop < item.endSec
        );

        document.querySelectorAll("#playlist li").forEach((li) => {
          const i = Number(li.dataset.index);
          const startEl = document.getElementById(`start-${i}`);
          const endEl = document.getElementById(`end-${i}`);

          if (i === idx) {
            li.classList.remove("opacity-50");
            li.classList.add("opacity-100", "playing");
            startEl.classList.remove("text-gray-400");
            endEl.classList.remove("text-gray-400");
            startEl.classList.add("text-blue-600");
            endEl.classList.add("text-blue-600");
          } else {
            li.classList.add("opacity-50");
            li.classList.remove("opacity-100", "playing");
            startEl.classList.add("text-gray-400");
            endEl.classList.add("text-gray-400");
            startEl.classList.remove("text-blue-600");
            endEl.classList.remove("text-blue-600");
          }
        });
      }

      function updateProgress(secInLoop) {
        schedule.forEach((item, i) => {
          const bar = document.getElementById(`p-${i}`);
          const startEl = document.getElementById(`start-${i}`);
          const endEl = document.getElementById(`end-${i}`);

          if (!bar || !startEl || !endEl) return;

          const total = item.endSec - item.startSec;
          const passed = secInLoop - item.startSec;
          const remain = item.endSec - secInLoop;

          if (secInLoop >= item.startSec && secInLoop < item.endSec) {
            const pct = (passed / total) * 100;
            bar.style.width = `${pct}%`;
            startEl.textContent = `+${formatTimeMMSS(passed)}`;
            endEl.textContent = `-${formatTimeMMSS(remain)}`;
          } else {
            bar.style.width = "0%";
            startEl.textContent = `+0:00`;
            endEl.textContent = `-0:00`;
          }
        });
      }

      function updateCounts(cycles, secInLoop) {
        const counts = {
          kakurenbo: cycles * PER_CYCLE.kakurenbo,
          rizz: cycles * PER_CYCLE.rizz,
          chroma: cycles * PER_CYCLE.chroma,
        };

        schedule.forEach((item) => {
          if (item.startSec <= secInLoop) {
            if (item.title === TARGETS.kakurenbo) counts.kakurenbo += 1;
            else if (item.title === TARGETS.rizz) counts.rizz += 1;
            else if (item.title === TARGETS.chroma) counts.chroma += 1;
          }
        });

        document.getElementById("count-kakurenbo").textContent =
          counts.kakurenbo;
        document.getElementById("count-rizz").textContent = counts.rizz;
        document.getElementById("count-chroma").textContent = counts.chroma;
      }

      loadSchedule();
    </script>

    <style>
      html,
      body {
        background-color: white;
      }
    </style>

    <!-- Firebase 모듈 기반 스크립트 -->
    <script type="module">
      // ✅ [수정] import 구문은 스크립트의 가장 최상단에 위치해야 합니다.
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
      import {
        getMessaging,
        getToken,
        onMessage,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-messaging.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-analytics.js";

      // 무한 루프 방지를 위한 깃발(플래그)
      if (window.firebaseHasBeenInitialized) {
        // 이미 초기화되었다면 아무것도 하지 않음
      } else {
        // 처음 실행되는 경우, 깃발을 세웁니다.
        window.firebaseHasBeenInitialized = true;

        // ✅ [수정] import를 제외한 나머지 모든 로직은 이 else 블록 안에 위치합니다.
        const firebaseConfig = {
          apiKey: "AIzaSyDam42H9W_iouj0rkMZDDzSWsrmx8BlVkQ",
          authDomain: "plli-checker.firebaseapp.com",
          projectId: "plli-checker",
          storageBucket: "plli-checker.firebasestorage.app",
          messagingSenderId: "517953309352",
          appId: "1:517953309352:web:a5c5a3919ff5bd8822d09d",
          measurementId: "G-GYGLSJRN79",
        };

        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const messaging = getMessaging(app);

        let currentToken = null;
        let lastSentToken = null;
        let lastSentOptIn = null;

        function saveFCMTokenToServer(token, alarmOptIn) {
          if (token === lastSentToken && alarmOptIn === lastSentOptIn) {
            return;
          }
          lastSentToken = token;
          lastSentOptIn = alarmOptIn;
          fetch("http://localhost:3001/api/save-token", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token, alarmOptIn }),
          }).then((res) => console.log("서버 응답 상태:", res.status));
        }

        if ("serviceWorker" in navigator) {
          navigator.serviceWorker
            .register("/firebase-messaging-sw.js")
            .then((registration) => navigator.serviceWorker.ready)
            .then((readyRegistration) => {
              console.log("✅ 서비스 워커 준비 완료!");
              // ✅ [수정] 준비된 서비스 워커 등록 정보를 함수에 인자로 전달
              requestPermissionAndToken(readyRegistration);
            })
            .catch((error) =>
              console.error("❌ 서비스 워커 처리 중 오류:", error)
            );
        }

        // ✅ [수정] 함수가 registration 객체를 인자로 받도록 변경
        function requestPermissionAndToken(registration) {
          Notification.requestPermission().then((permission) => {
            if (permission !== "granted") {
              console.warn("🔕 알림 권한이 거부되었습니다.");
              return;
            }
            console.log("알림 권한 허용됨. 토큰 요청 중...");
            // ✅ [수정] getToken에 serviceWorkerRegistration을 명시적으로 전달
            getToken(messaging, {
              vapidKey:
                "BHKOgIoE52ImNaT3yKv_w1yJVSPL2WfUZHCp2VKUF0DvWiOVi2cNFQ-qS2XzjRt2HliwcK-U-BFrDXbxBfpI7MA",
              serviceWorkerRegistration: registration,
            })
              .then((token) => {
                if (!token) {
                  console.log("토큰 발급 불가. 설정 확인 필요.");
                  return;
                }
                currentToken = token;
                const alarmOptIn =
                  localStorage.getItem("alarmOptIn") === "true";
                saveFCMTokenToServer(token, alarmOptIn);
                console.log("📲 FCM Token:", token);
              })
              .catch((err) => console.error("❌ 토큰 가져오기 실패:", err));
          });
        }

        onMessage(messaging, (payload) => {
          console.log("📥 포그라운드 메시지:", payload);
          alert(payload.notification?.title || "알림이 도착했습니다");
        });

        const toggle = document.getElementById("alarm-toggle");
        if (toggle) {
          toggle.checked = localStorage.getItem("alarmOptIn") === "true";
          toggle.addEventListener("change", (e) => {
            const isOn = e.target.checked;
            localStorage.setItem("alarmOptIn", isOn ? "true" : "false");
            if (currentToken) {
              saveFCMTokenToServer(currentToken, isOn);
            }
          });
        }
      }
    </script>
  </body>
</html>
